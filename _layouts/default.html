<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
    <link rel="stylesheet" href="{{ 'assets/water.css' | relative_url }}">
    <link rel="stylesheet" href="{{ 'assets/main.css' | relative_url }}">
    <script type="text/javascript" src="{{ 'assets/main.js' | relative_url }}" defer async></script>
    <script type="text/javascript" src="https://www.youtube.com/iframe_api" async defer></script>
  </head>
  <body>
    <nav style="position: fixed;">
      <!-- <a href="/">Home</a> -->
      <!-- <a href="/blog/">Blog</a> -->
      <!-- <a href="#ru">RU</a> -->
    </nav>
    <div class="content">
      <!--<div class="video-container">
        <iframe id="player" class="video" src="https://www.youtube.com/embed/{{ page.video }}?autoplay=0&fs=0&controls=1&iv_load_policy=3&modestbranding=1&rel=0&enablejsapi=1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
      <script>
        var player;
        function onYouTubeIframeAPIReady() {
          player = new YT.Player('player', {
            events: {
              'onReady': onPlayerReady
            }
          });
        }

        // 4. The API will call this function when the video player is ready.
        function onPlayerReady(e) {
          // const [slow] = player.getAvailablePlaybackRates()
          // player.setVolume(0)
          // player.setPlaybackRate(slow)
          // player.playVideo();
          player.addEventListener('onStateChange', function onPlayerStateChange(e) {
            // if (e.data === 1) setTimeout(() => {
            //   player.pauseVideo()
            //   player.setVolume(1)
            //   player.setPlaybackRate(1)
            // }, 300)
          })
        }


        // 5. The API calls this function when the player's state changes.
        //    The function indicates that when playing a video (state=1),
        //    the player should play for six seconds and then stop.
        // var done = false;
        // function onPlayerStateChange(event) {
        //   if (event.data == YT.PlayerState.PLAYING && !done) {
        //     setTimeout(stopVideo, 6000);
        //     done = true;
        //   }
        // }
        // function stopVideo() {
        //   player.stopVideo();
        // }
      </script>-->

      <main>
        <header>
          <!-- <h1>
            Mayapur Mridanga Tutorial 1. {{ page.title }}
            <a href="" class="next">→ 2.</a>
          </h1> -->
        </header>
        {{ content }}
        <script type="module">
          const mainEl = document.querySelector('main')
          const h2s = [...mainEl.querySelectorAll('h2')]
          const mantraEls = mainEl.querySelectorAll('blockquote')

          // Add ids to headers
          // h2s.forEach(h2 => h2.id = h2.textContent.split('.')[0].toLowerCase().replace(' ','-'))

          // Wrap into sections
          h2s.forEach(h2 => {
            const sectionEl = document.createElement('details')
            sectionEl.id = h2.id
            h2.removeAttribute('id')
            h2.replaceWith(sectionEl)
            let summary
            sectionEl.appendChild(summary = document.createElement('summary')).appendChild(h2)
            while (sectionEl?.nextElementSibling && sectionEl?.nextElementSibling?.tagName !== 'H2') {
              const bq = sectionEl?.nextElementSibling
              if (bq.tagName === 'BLOCKQUOTE') {
                sectionEl.append(bq.querySelector('a') || '')
                bq.textContent = bq.textContent.trim();
              }
              sectionEl.appendChild(bq)
            }
            // NOTE: don't update sections to keep even spread of titles
            // summary.addEventListener('click', e => requestAnimationFrame(toc))
          })
          const sections = document.querySelectorAll('details')

          // TOC: collect all headers, place into TOC div
          let tocEl = document.createElement('nav')
          tocEl.className = 'toc'
          mainEl.appendChild(tocEl)
          tocEl.append(...h2s.map(h2 => {
            let a = document.createElement('a')
            a.textContent = h2.textContent.split('.')[0].split(' ')[1]
            a.href=`#${h2.closest('details').id}`
            a.title = h2.textContent
            return a
          }))
          toc()
          // update toc position
          function toc () {
            [...tocEl.childNodes].forEach((a,i) => {
              // const target = document.querySelector(a.hash)
              const target = h2s[i]
              Object.assign(a.style, {
                top: `${100*target.parentNode.offsetTop/document.body.scrollHeight}vh`
              })
            })
          }

          // highlight in-view title
          const observer = new IntersectionObserver(entries => {
              entries.forEach(entry => {
                const id = entry.target.id;
                if (entry.isIntersecting) {
                  tocEl.querySelector(`[href="#${id}"]`).classList.add('in-view');
                } else {
                  tocEl.querySelector(`[href="#${id}"]`).classList.remove('in-view');
                }
              });
            });
          sections.forEach((section) => observer.observe(section));


          // camelcasify mantras
          const dict = {
            THUN: 'Thun',
            TATAKHA: 'TaTaKha',
            TAKHA: 'TaKha',
            TAKHE: 'TaKhe',
            TAKHI: 'TaKhi',
            TAKA: 'TaKa',
            TAK: 'Tak',
            TATA: 'TaTa',
            TAT: 'Tat',
            TAAT: 'Taat',
            THAAT: 'Thaat',
            TA: 'Ta',
            TEE: 'Tee',
            TE: 'Te',
            THEI: 'Thei',
            THE: 'The',
            THI: 'Thi',
            TI: 'Ti',
            DRE: 'Dre',
            DAAD: 'Daad',
            DAD: 'Dad',
            DHAT: 'Dhat',
            DHA: 'Dha',
            DA: 'Da',
            DHEI: 'Dhei',
            DHE: 'Dhe',
            DHO: 'Dho',
            DHINI: 'Dhini',
            DHIN: 'Dhin',
            DHI: 'Dhi',
            DI: 'Di',
            DHAT: 'Dhat',
            DE: 'De',
            NING: 'Ning',
            NI: 'Ni',
            NE: 'Ne',
            NAG: 'Nag',
            NAK: 'Nak',
            NAW: 'Naw',
            NA: 'Na',
            KAAT: 'Kaat',
            KHER: 'Kher',
            KE: 'Ke',
            KHE: 'Khe',
            KA: 'Ka',
            KO: 'Ko',
            KHA: 'Kha',
            KHI: 'Khi',
            // GED: 'Ged',
            GHER: 'Gher',
            GHE: 'Ghe',
            GHI: 'Ghi',
            GI: 'Ghi',
            GA: 'Ga',
            GE: 'Ge',
            JA: 'Ja',
            JHA: 'Jha',
            JHEI: 'Jhei',
            JHE: 'Jhe',
            JHI: 'Jhi',
            RE: 'Re',
            GURU: 'GuRu',
            URU: 'Uru',
            GUR: 'GuR',
            YA: 'Ya'
          }
          const symbols = {
            TE: '|̲|̲|̲|̲',
            RE: '/',
            KHE: '●',
            TA: '||||'
          }
          mantraEls.forEach(el => {
            for (let key in dict) {
              el.innerHTML = el.innerHTML.replaceAll(
                key, `<i data-sym="${symbols[key] || ''}">${dict[key]}</i>`
              )
            }
          })
        </script>
      </main>
    </div>

    <footer class="footer">
      <a href="https://krishnized.com">ॐ</a>
      <br/>
    </footer>
  </body>
</html>
