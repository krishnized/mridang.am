<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
    <link rel="stylesheet" href="{{ 'assets/water.css' | relative_url }}">
    <link rel="stylesheet" href="{{ 'assets/main.css' | relative_url }}">
    <script type="text/javascript" src="{{ 'assets/main.js' | relative_url }}" defer async></script>
    <script type="text/javascript" src="https://www.youtube.com/iframe_api" async defer></script>
  </head>
  <body>
    <nav style="position: fixed;">
      <!-- <a href="/">Home</a> -->
      <!-- <a href="/blog/">Blog</a> -->
      <!-- <a href="#ru">RU</a> -->
    </nav>
    <div class="content">
      <!--<div class="video-container">
        <iframe id="player" class="video" src="https://www.youtube.com/embed/{{ page.video }}?autoplay=0&fs=0&controls=1&iv_load_policy=3&modestbranding=1&rel=0&enablejsapi=1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
      <script>
        var player;
        function onYouTubeIframeAPIReady() {
          player = new YT.Player('player', {
            events: {
              'onReady': onPlayerReady
            }
          });
        }

        // 4. The API will call this function when the video player is ready.
        function onPlayerReady(e) {
          // const [slow] = player.getAvailablePlaybackRates()
          // player.setVolume(0)
          // player.setPlaybackRate(slow)
          // player.playVideo();
          player.addEventListener('onStateChange', function onPlayerStateChange(e) {
            // if (e.data === 1) setTimeout(() => {
            //   player.pauseVideo()
            //   player.setVolume(1)
            //   player.setPlaybackRate(1)
            // }, 300)
          })
        }


        // 5. The API calls this function when the player's state changes.
        //    The function indicates that when playing a video (state=1),
        //    the player should play for six seconds and then stop.
        // var done = false;
        // function onPlayerStateChange(event) {
        //   if (event.data == YT.PlayerState.PLAYING && !done) {
        //     setTimeout(stopVideo, 6000);
        //     done = true;
        //   }
        // }
        // function stopVideo() {
        //   player.stopVideo();
        // }
      </script>-->

      <main>
        <header>
          <h1>
            {{ page.title }}
            <br/><em><small>by {{ page.author }}</small></em>
            <!-- <a href="" class="next">→ 2.</a> -->
          </h1>
        </header>
        {{ content }}
        <script type="module">
          import {$, h} from './assets/lib/spect.js'
          import {dict, symbols} from './assets/dict.js'

          // TOC: collect all headers, place into TOC div
          let tocEl = h`<nav class="toc"></nav>`
          document.querySelector('.content').appendChild(tocEl)

          // Wrap  h2s into sections
          $('main > h2', h2 => {
            const sectionEl = h`<details class=section id=${h2.id}>
              <summary class="title"><h2>${h2.textContent}</h2></summary>
            </details>`
            // const sectionEl =
            while (h2?.nextElementSibling) {
              const bq = h2?.nextElementSibling
              if (bq.tagName === 'H2') break;
              if (bq.tagName === 'BLOCKQUOTE') {
                const quoteHref = bq.querySelector('a')
                quoteHref?.remove()
                const quoteTitle = h`<span class="subtitle">${quoteHref?.textContent || ''}</span>`
                sectionEl.append(quoteTitle)
                bq.textContent = bq.textContent.trim();
              }
              sectionEl.appendChild(bq)
            }
            h2.replaceWith(sectionEl)
          })

          $('main > details', sectionEl => {
            const title = sectionEl.querySelector('.title').textContent
            // // NOTE: don't update sections to keep even spread of titles
            // // summary.addEventListener('click', e => requestAnimationFrame(toc))

            let a = h`<a
              href="#${sectionEl.id}"
              title=${title}
              style="top: ${100*sectionEl.offsetTop/document.body.scrollHeight}vh"
              >
                ${title.split('.')[0].split(' ')[1]}
              </a>`
            tocEl.append(a)

            // highlight in-view title
            const observer = new IntersectionObserver(entries => {
              entries.forEach(entry => {
                const id = entry.target.id;
                if (entry.isIntersecting) {
                  tocEl.querySelector(`[href="#${id}"]`).classList.add('in-view');
                } else {
                  tocEl.querySelector(`[href="#${id}"]`).classList.remove('in-view');
                }
              });
            });
            observer.observe(sectionEl)
          })


          // CamelCase mantras, add visual helpers
          $('blockquote', el => {
            let str = el.innerHTML
            for (let key in dict) {
              str = str.replaceAll(
                key, `<i data-sym="${symbols[key] || ''}">${dict[key]}</i>`
              )
            }
            el.innerHTML = str
          })
        </script>
      </main>
    </div>

    <footer class="footer">
      <a href="https://krishnized.com">ॐ</a>
      <br/>
    </footer>
  </body>
</html>
